https://blog.csdn.net/qq_26222859/article/details/80631121
https://blog.csdn.net/z_ryan/article/details/79685072
https://www.cnblogs.com/nullzx/p/8729425.html这篇蛮好的

1. B树的定义

B树也称B-树,它是一颗多路平衡查找树。我们描述一颗B树时需要指定它的阶数，阶数表示了一个结点最多有多少个孩子结点，一般用字母m表示阶数。
当m取2时，就是我们常见的二叉搜索树。

一颗m阶的B树定义如下：如果B树的阶数为m，则结点中关键字个数的范围为ceil(m/2)-1 ~ m-1个。这里ceil代表向上取整。

1）每个结点最多有m-1个关键字。

2）根结点最少可以只有1个关键字。

3）非根结点至少有Math.ceil(m/2)-1个关键字。

4）每个结点中的关键字都按照从小到大的顺序排列，每个关键字的左子树中的所有关键字都小于它，而右子树中的所有关键字都大于它。

5）所有叶子结点都位于同一层，或者说根结点到每个叶子结点的长度都相同。

大家在网上搜索时会发现定义并不唯一，普遍采用了m阶（代表order，中文翻译为阶）来定义：
每个节点最多有m个孩子。
每个内部节点（除去叶节点和根节点）至少有⌈m/2⌉（向上取整）孩子。
如果根不是叶节点，则根至少有两个孩子。
所有叶子都出现在同一层。
具有k个孩子的非叶节点包含k-1个键，当然节点内的键也是递增的。
还有个关键点：即便是每个节点没有存满，也需要分配固定大小的容量，所以才有了存储利用率大于50%一说。（不懂的话 看图解）

一个m阶的B树具有如下几个特征：

1.根结点至少有两个子女。（前提是不为空树）

2.每个中间节点都包含k-1个元素和k个孩子，其中 m/2 <= k <= m

3.每一个叶子节点都包含k-1个元素，其中 m/2 <= k <= m

4.所有的叶子结点都位于同一层。

5.每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划。
在实际应用中的B树的阶数m都非常大（通常大于100），所以即使存储大量的数据，B树的高度仍然比较小。
每个结点中存储了关键字（key）和关键字对应的数据（data），以及孩子结点的指针。我们将一个key和其对应的data称为一个记录。
但为了方便描述，除非特别说明，后续文中就用key来代替（key, value）键值对这个整体。
在数据库中我们将B树（和B+树）作为索引结构，可以加快查询速速，此时B树中的key就表示键，而data表示了这个键对应的条目在硬盘上的逻辑地址。


1）每个结点最多有m个分支（子树）；而最少分支数要看是否为根结点，如果是根结点且不是叶子结点，则至少要有两个分支，
非根非叶结点至少有ceil(m/2)个分支，这里ceil代表向上取整。

2）如果一个结点有n-1个关键字，那么该结点有n个分支。这n-1个关键字按照递增顺序排列。

3）每个节点的结构为

节点个数：n；

关键字数组： k[n]，这n个关键字按照递增顺序排列

孩子指针数组：p[n + 1], p0<=k1, 之后所有 ki < pi <= ki+1;

查找操作（中序遍历）

1）先让key与根结点中的关键字比较，如果key等于k[i]（k[]为结点内的关键字数组），则查找成功

2）若key<k[1]，则到p[0]所指示的子树中进行继续查找（p[]为结点内的指针数组），这里要注意B-树中每个结点的内部结构。

3）若key>k[n]，则道p[n]所指示的子树中继续查找。

4）若k[i]<key<k[i+1]，则沿着指针p[I]所指示的子树继续查找。

5）如果最后遇到空指针，则证明查找不成功。

如果查找22，过程为22小于30，往p0指针走，到达15,26这个内节点，然后对比发现属于15到26区间，往p[1]走，找到22；

注意
　　①、B树主要用于文件系统以及部分数据库索引，例如： MongoDB。而大部分关系数据库则使用B+树做索引，例如：mysql数据库；
　　②、从查找效率考虑一般要求B树的阶数m >= 3;
　　③、B-树上算法的执行时间主要由读、写磁盘的次数来决定，故一次I/O操作应读写尽可能多的信息。因此B-树的结点规模一般以一个磁盘页为单位。
    一个结点包含的关键字及其孩子个数取决于磁盘页的大小。


